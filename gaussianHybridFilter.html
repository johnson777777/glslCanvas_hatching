<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaussian Hybrid Filter</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: Arial, sans-serif;
        }
        
        .container {
            display: flex;
            gap: 20px;
        }
        
        .canvas-container {
            flex: 1;
        }
        
        #glslCanvas {
            border: 1px solid #333;
            max-width: 100%;
        }
        
        .controls {
            width: 300px;
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .control-group input[type="file"] {
            width: 100%;
            padding: 5px;
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
        }
        
        .control-group input[type="checkbox"] {
            margin-right: 10px;
        }
        
        .value-display {
            font-size: 12px;
            color: #aaa;
        }
        
        .image-previews {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .image-preview {
            width: 100px;
            height: 75px;
            border: 1px solid #555;
            background-color: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #aaa;
        }
        
        .image-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: cover;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-container">
            <canvas id="glslCanvas" width="800" height="600"></canvas>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>Low-pass Image:</label>
                <input type="file" id="imgLowInput" accept="image/*">
                <div class="image-preview" id="imgLowPreview">No image</div>
            </div>
            
            <div class="control-group">
                <label>High-pass Image:</label>
                <input type="file" id="imgHighInput" accept="image/*">
                <div class="image-preview" id="imgHighPreview">No image</div>
            </div>
            
            <div class="control-group">
                <label>Low-pass Sigma: <span class="value-display" id="sigmaLowValue">8.0</span></label>
                <input type="range" id="sigmaLow" min="0.1" max="8.0" step="0.1" value="8.0">
            </div>
            
            <div class="control-group">
                <label>High-pass Sigma: <span class="value-display" id="sigmaHighValue">3.6</span></label>
                <input type="range" id="sigmaHigh" min="0.1" max="8.0" step="0.1" value="3.6">
            </div>
            
            <div class="control-group">
                <label>Low-pass Gain: <span class="value-display" id="gainLowValue">1.0</span></label>
                <input type="range" id="gainLow" min="0.0" max="2.0" step="0.05" value="1.0">
            </div>
            
            <div class="control-group">
                <label>High-pass Gain: <span class="value-display" id="gainHighValue">1.0</span></label>
                <input type="range" id="gainHigh" min="0.0" max="2.0" step="0.05" value="1.0">
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="gammaCorrect">
                    Gamma Correction
                </label>
            </div>
        </div>
    </div>

    <script>
        // WebGL context and shader program
        let gl, program, vertexBuffer, indexBuffer;
        let uniforms = {};
        let textures = { low: null, high: null };
        
        // Vertex shader source
        const vertexShaderSource = `#version 300 es
            in vec4 aPosition;
            in vec2 aTexCoord;
            out vec2 vUV;
            
            void main() {
                vUV = aTexCoord;
                gl_Position = aPosition;
            }
        `;
        
        // Fragment shader will be loaded from external file
        let fragmentShaderSource = null;
        
        // Load shader source from file
        async function loadShaderSource(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to load shader: ${response.statusText}`);
                }
                return await response.text();
            } catch (error) {
                console.error('Error loading shader:', error);
                return null;
            }
        }
        
        // Initialize WebGL
        function initWebGL() {
            const canvas = document.getElementById('glslCanvas');
            gl = canvas.getContext('webgl2');
            
            if (!gl) {
                alert('WebGL 2.0 is not supported in this browser');
                return false;
            }
            
            return true;
        }
        
        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        // Create shader program
        function createShaderProgram() {
            const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
            
            if (!vertexShader || !fragmentShader) {
                return null;
            }
            
            program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                return null;
            }
            
            gl.useProgram(program);
            
            // Get uniform locations
            uniforms.uImgLow = gl.getUniformLocation(program, 'uImgLow');
            uniforms.uImgHigh = gl.getUniformLocation(program, 'uImgHigh');
            uniforms.uTexSize = gl.getUniformLocation(program, 'uTexSize');
            uniforms.uSigmaLow = gl.getUniformLocation(program, 'uSigmaLow');
            uniforms.uSigmaHigh = gl.getUniformLocation(program, 'uSigmaHigh');
            uniforms.uGainLow = gl.getUniformLocation(program, 'uGainLow');
            uniforms.uGainHigh = gl.getUniformLocation(program, 'uGainHigh');
            uniforms.uGammaCorrect = gl.getUniformLocation(program, 'uGammaCorrect');
            
            return program;
        }
        
        // Create geometry (full-screen quad)
        function createGeometry() {
            // Vertices: position (x, y) and texture coordinates (u, v)
            // Note: V coordinates are flipped to correct for WebGL's Y-axis orientation
            const vertices = new Float32Array([
                -1.0, -1.0, 0.0, 1.0,  // bottom-left (V flipped: was 0.0, now 1.0)
                 1.0, -1.0, 1.0, 1.0,  // bottom-right (V flipped: was 0.0, now 1.0)
                 1.0,  1.0, 1.0, 0.0,  // top-right (V flipped: was 1.0, now 0.0)
                -1.0,  1.0, 0.0, 0.0   // top-left (V flipped: was 1.0, now 0.0)
            ]);
            
            const indices = new Uint16Array([
                0, 1, 2,  // first triangle
                0, 2, 3   // second triangle
            ]);
            
            // Create and bind vertex buffer
            vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            
            // Create and bind index buffer
            indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
            
            // Set up vertex attributes
            const aPosition = gl.getAttribLocation(program, 'aPosition');
            const aTexCoord = gl.getAttribLocation(program, 'aTexCoord');
            
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 16, 0);
            
            gl.enableVertexAttribArray(aTexCoord);
            gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 16, 8);
        }
        
        // Create texture from image
        function createTexture(image) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            
            return texture;
        }
        
        // Load image and create texture
        function loadImage(file, callback) {
            const img = new Image();
            img.onload = function() {
                callback(img);
            };
            img.src = URL.createObjectURL(file);
        }
        
        // Render function
        function render() {
            if (!textures.low || !textures.high) {
                return;
            }
            
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            // Bind textures
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures.low);
            gl.uniform1i(uniforms.uImgLow, 0);
            
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, textures.high);
            gl.uniform1i(uniforms.uImgHigh, 1);
            
            // Set uniforms
            const canvas = document.getElementById('glslCanvas');
            gl.uniform2f(uniforms.uTexSize, canvas.width, canvas.height);
            gl.uniform1f(uniforms.uSigmaLow, parseFloat(document.getElementById('sigmaLow').value));
            gl.uniform1f(uniforms.uSigmaHigh, parseFloat(document.getElementById('sigmaHigh').value));
            gl.uniform1f(uniforms.uGainLow, parseFloat(document.getElementById('gainLow').value));
            gl.uniform1f(uniforms.uGainHigh, parseFloat(document.getElementById('gainHigh').value));
            gl.uniform1i(uniforms.uGammaCorrect, document.getElementById('gammaCorrect').checked ? 1 : 0);
            
            // Draw
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        }
        
        // Initialize everything
        async function init() {
            if (!initWebGL()) {
                return;
            }
            
            // Load fragment shader from external file
            fragmentShaderSource = await loadShaderSource('gaussianHybridFilter.frag');
            if (!fragmentShaderSource) {
                alert('Failed to load fragment shader');
                return;
            }
            
            if (!createShaderProgram()) {
                return;
            }
            
            createGeometry();
            
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            
            // Load default images if available
            loadDefaultImages();
        }
        
        // Load default images from your data folder
        function loadDefaultImages() {
            const imgLow = new Image();
            imgLow.onload = function() {
                textures.low = createTexture(imgLow);
                document.getElementById('imgLowPreview').innerHTML = '<img src="' + imgLow.src + '" alt="Low-pass">';
                checkAndRender();
            };
            imgLow.src = 'data/tomb.png';
            
            const imgHigh = new Image();
            imgHigh.onload = function() {
                textures.high = createTexture(imgHigh);
                document.getElementById('imgHighPreview').innerHTML = '<img src="' + imgHigh.src + '" alt="High-pass">';
                checkAndRender();
            };
            imgHigh.src = 'data/shake.webp';
        }
        
        function checkAndRender() {
            if (textures.low && textures.high) {
                render();
            }
        }
        
        // Event listeners
        document.getElementById('imgLowInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                loadImage(file, function(img) {
                    textures.low = createTexture(img);
                    document.getElementById('imgLowPreview').innerHTML = '<img src="' + img.src + '" alt="Low-pass">';
                    checkAndRender();
                });
            }
        });
        
        document.getElementById('imgHighInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                loadImage(file, function(img) {
                    textures.high = createTexture(img);
                    document.getElementById('imgHighPreview').innerHTML = '<img src="' + img.src + '" alt="High-pass">';
                    checkAndRender();
                });
            }
        });
        
        // Control value updates
        ['sigmaLow', 'sigmaHigh', 'gainLow', 'gainHigh'].forEach(id => {
            const element = document.getElementById(id);
            element.addEventListener('input', function() {
                document.getElementById(id + 'Value').textContent = this.value;
                render();
            });
        });
        
        document.getElementById('gammaCorrect').addEventListener('change', render);
        
        // Initialize on page load
        window.addEventListener('load', init);
    </script>
</body>
</html>